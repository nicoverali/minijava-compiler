package lexical.automata.tokenizer.strategy;

import io.code.CodeCharacter;
import io.code.CodeLine;
import lexical.Lexeme;
import lexical.LexicalException;
import lexical.Token;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Optional;

public interface TokenizerNodeStrategy {

    /**
     * Determines what to do in case no branch can match a certain character.
     * <br>
     * It will return a {@link Token} if it can generate one, or a {@link LexicalException} if the node detects
     * a lexical error.
     * <br>
     * If there was no lexical error but the node could not generate a {@link Token}, then an empty {@link Optional}
     * will be returned
     *
     *
     * @param lexeme the current {@link Lexeme}
     * @param currentCharacter the current {@link CodeCharacter}
     * @return an {@link Optional} wrapping a {@link Token} generated by the node
     * @throws LexicalException if the node detects a lexical error
     */
    Optional<Token> onNoBranchSelected(@NotNull Lexeme lexeme, @NotNull CodeCharacter currentCharacter) throws LexicalException;

    /**
     * Similar to {@link #onNoBranchSelected}, but determines what to do when the end of file is reached.
     *
     * @param lexeme the current {@link Lexeme}
     * @param currentLine the current {@link CodeLine}
     * @return an {@link Optional} wrapping a {@link Token} generated by the node
     * @throws LexicalException if the node detects a lexical error
     */
    Optional<Token> onEndOfFile(@Nullable Lexeme lexeme, @Nullable CodeLine currentLine) throws LexicalException;
}
