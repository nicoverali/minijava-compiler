package lexical.automata.tokenizer.strategy;

import io.code.CodeCharacter;
import io.code.CodeLine;
import lexical.LexicalException;
import lexical.Token;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Optional;

public interface TokenizerNodeStrategy {

    /**
     * Determines what to do in case no branch can match a certain character.
     * <br>
     * It will return a {@link Token} if it can generate one, or a {@link LexicalException} if the node detects
     * a lexical error.
     * <br>
     * If there was no lexical error but the node could not generate a {@link Token}, then an empty {@link Optional}
     * will be returned
     *
     * @param currentCharacter the current {@link CodeCharacter}
     * @return a {@link Token} generated by the node, or null if no Token has been generate
     * @throws LexicalException if the node detects a lexical error
     */
    @NotNull
    Token onNoBranchSelected(@NotNull CodeCharacter currentCharacter) throws LexicalException;

    /**
     * Similar to {@link #onNoBranchSelected}, but determines what to do when the end of file is reached.
     *
     * @param currentLine the current {@link CodeLine}
     * @return a {@link Token} generated by the node, or null if no Token has been generate
     * @throws LexicalException if the node detects a lexical error
     */
    @NotNull
    Token onEndOfFile(@Nullable CodeLine currentLine) throws LexicalException;
}
