package lexical.automata;

import io.code.reader.SourceCodeReader;
import lexical.Lexeme;
import lexical.LexicalException;
import org.jetbrains.annotations.NotNull;

/**
 * This type of branches are able to delegate work to the next associated node. If the next node returns an element
 * of type <code>U</code>, it will be returned.
 *
 * @param <T> type of {@link LexicalNode} connected by this branch
 * @param <U> type of return value by delegating
 */
public interface DelegateNodeBranch<T extends LexicalNode<?,?>, U> extends NodeBranch<T>{

    /**
     * Delegates work to the next node. This will consume the next character from the <code>reader</code>
     * It returns an element of type {@link U} generated by the next node.
     * If a lexical error is detected, then a LexicalException with the current {@link Lexeme} will be propagated.
     *
     * @param reader a {@link SourceCodeReader} to take emitted characters as input
     * @return a element of type {@link U} generated by the next node
     * @throws LexicalException if a lexical error is detected
     */
    @NotNull
    U delegate(SourceCodeReader reader) throws LexicalException;

}
