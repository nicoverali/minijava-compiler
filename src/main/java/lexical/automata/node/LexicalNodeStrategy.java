package lexical.automata.node;

import io.code.CodeCharacter;
import io.code.CodeLine;
import io.code.SourceCodeReader;
import lexical.LexicalException;
import lexical.Token;
import lexical.automata.LexicalNode;

/**
 * The strategy of a {@link LexicalNode} determines what it should do when the processing of
 * characters cannot be delegated.
 */
public interface LexicalNodeStrategy {

    /**
     * Determines what to do in case no branch can match a certain character.
     * <br>
     * It will return a {@link Token} if it can generate one, or a <code>null</code> value
     * <br><br>
     * If a lexical error is detected then it will throw a {@link LexicalException}
     *
     *
     * @param reader the {@link SourceCodeReader} used by the node
     * @param currentCharacter the current {@link CodeCharacter}
     * @return a {@link Token} generated by the node strategy, or <code>null</code>
     * @throws LexicalException if the node detects a lexical error
     */
    Token onNoBranchSelected(SourceCodeReader reader, CodeCharacter currentCharacter) throws LexicalException;

    /**
     * Similar to {@link #onNoBranchSelected}, but determines what to do when the end of file is reached.
     *
     *
     * @param reader the {@link SourceCodeReader} used by the node
     * @param currentLine the current {@link CodeLine}
     * @return a {@link Token} generated by the node strategy, or <code>null</code>
     * @throws LexicalException if the node detects a lexical error
     */
    Token onEndOfFile(SourceCodeReader reader, CodeLine currentLine) throws LexicalException;
}
