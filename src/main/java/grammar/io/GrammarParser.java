package grammar.io;

import com.google.common.collect.Lists;
import grammar.Grammar;
import grammar.GrammarBody;
import grammar.GrammarTerm;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

public class GrammarParser {

    private final GrammarValidator validator;
    private Collection<String> heads;
    private int lineNumber;
    private String lambda;

    public GrammarParser(GrammarValidator validator){
        this.validator = validator;
    }

    /**
     * Converts an array of Strings where each one is a line in the grammar source file, to a {@link Grammar} instance.
     * It will use the {@link GrammarValidator} set in the constructor to validate that the grammar is correct and
     * also to translate every terminal term.
     *
     * @param lines a String array where each is a line in the grammar source file
     * @param lambda the symbol use as lambda in the grammar source file
     * @return a {@link Grammar} generated by parsing the given lines
     */
    public Grammar parse(String[] lines, String lambda){
        this.lambda = lambda;
        List<List<String>> linesList = linesToList(lines);
        heads = saveAllHeads(linesList);

        return parseGrammar(linesList);
    }

    private Collection<String> saveAllHeads(List<List<String>> linesList) {
        return linesList.stream()
                .map(line -> line.get(0))
                .collect(Collectors.toSet());
    }

    private Grammar parseGrammar(List<List<String>> lines){
        Grammar grammar = new Grammar();
        lineNumber = 1;
        for (List<String> line : lines){
            checkConnective(line);
            grammar.addAll(parseHead(line), parseBodies(line));
            lineNumber++;
        }
        return grammar;
    }

    private void checkConnective(List<String> list){
        if (!list.get(1).equals("::=")){
            System.err.println("WARNING: Connective at line "+lineNumber+" is not right.");
        }
    }

    private GrammarTerm parseHead(List<String> list){
        String head = list.get(0);
        if (!isNonTerminal(head)) throw new IllegalArgumentException("The head at line "+lineNumber+" ( "+head+" ) is not a non terminal term");
        return new GrammarTerm(removeBrackets(head), true);
    }

    private List<GrammarBody> parseBodies(List<String> line){
        List<String> lineBody = line.subList(2, line.size());
        List<GrammarBody> bodies = new ArrayList<>();
        GrammarBody currentBody = new GrammarBody();
        for (String term : lineBody){
            if (term.equals("|")){
                bodies.add(currentBody);
                currentBody = new GrammarBody();
            } else if (isNonTerminal(term)){
                validator.validateNonTerminal(term, heads, lineNumber);
                currentBody.add(new GrammarTerm(removeBrackets(term), true, lineNumber));
            } else if (term.equals(lambda)){
                currentBody.add(new GrammarTerm(Grammar.LAMBDA, false, lineNumber));
            } else {
                String termName = validator.validateTerminal(term, lineNumber);
                currentBody.add(new GrammarTerm(termName, false, lineNumber));
            }
        }
        bodies.add(currentBody);
        return bodies;
    }

    private List<List<String>> linesToList(String[] lines){
        return Arrays.stream(lines)
                .map(line -> Lists.newArrayList(line.split("\\s+")))
                .collect(Collectors.toList());
    }

    private String removeBrackets(String nonTerminal){
        return nonTerminal.substring(1, nonTerminal.length()-1);
    }

    private boolean isNonTerminal(String term){
        return term.charAt(0) == '<' && term.charAt(term.length()-1) == '>';
    }

}
